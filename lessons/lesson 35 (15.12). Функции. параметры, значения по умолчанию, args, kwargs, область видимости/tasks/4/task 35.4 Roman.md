# Практическое задание 35.4

## Задания

### Описание задачи
В предыдущих блоках ты научился создавать функции, передавать аргументы разными способами и работать с `*args` и `**kwargs`. Теперь важно закрепить понимание **области видимости** переменных. В этом задании ты будешь работать с локальными и глобальными переменными, а также создашь простое замыкание для управления состоянием. Это подводит к умению структурировать программу, четко разделяя, где какая переменная "живет" и как на нее можно влиять.

Твоя задача — написать программу для учета посещений спортивных секций. В программе будет:
1.  **Глобальный словарь** `attendance`, хранящий общее количество посещений по каждой секции.
2.  Функция `mark_attendance(section, count=1)`, которая увеличивает счетчик посещений для указанной секции. Функция должна корректно работать с глобальной переменной `attendance`.
3.  Функция `create_section_tracker(section_name)`, которая возвращает **внутреннюю функцию-замыкание**. Эта внутренняя функция при каждом вызове должна увеличивать счетчик посещений для своей секции (используя глобальный `attendance`) и возвращать текущее значение счетчика для этой секции.

### Пример входных и выходных данных
**Пример 1: Работа с глобальной переменной**
```python
attendance = {}  # Изначально пустой словарь

# После вызовов mark_attendance:
mark_attendance("футбол", 5)
mark_attendance("баскетбол")
mark_attendance("футбол", 3)

print(attendance)
```
**Ожидаемый вывод:**
```
{'футбол': 8, 'баскетбол': 1}
```
*Пояснение:* Функция `mark_attendance` модифицирует глобальный словарь `attendance`. Для "футбола" сначала прибавилось 5, потом 3. Для "баскетбола" использовано значение по умолчанию `count=1`.

**Пример 2: Работа с замыканием**
```python
attendance = {}  # Начинаем с чистого словаря

track_swimming = create_section_tracker("плавание")
track_boxing = create_section_tracker("бокс")

print(track_swimming())  # Первый вызов для плавания
print(track_swimming())  # Второй вызов для плавания
print(track_boxing())    # Первый вызов для бокса
print(attendance)        # Проверяем глобальное состояние
```
**Ожидаемый вывод:**
```
1
2
1
{'плавание': 2, 'бокс': 1}
```
*Пояснение:* Функция `create_section_tracker` создает и возвращает функцию, которая "помнит" имя секции (`section_name`). Каждый вызов этой внутренней функции увеличивает счетчик в глобальном `attendance` для своей секции на 1 и возвращает новое значение.

### Критерии проверки и ограничения
1.  **Обязательное использование `global`:** В функции `mark_attendance` необходимо явно объявить `attendance` как глобальную переменную для ее изменения.
2.  **Значение по умолчанию:** У параметра `count` в `mark_attendance` должно быть значение по умолчанию `1`.
3.  **Замыкание:** Функция `create_section_tracker` должна возвращать другую функцию (замыкание), которая использует переданное `section_name` и обращается к глобальному `attendance`.
4.  **Обработка отсутствующей секции:** Если секции еще нет в словаре `attendance`, перед увеличением счетчика ее нужно добавить со значением 0 (или сразу с `count`).
5.  **Только пройденные темы:** Запрещено использовать классы, декораторы или другие конструкции, не изученные в рамках урока (область видимости, `global`, замыкание, базовые функции и словари).

### Решение задачи (псевдокод)
1.  Объяви глобальную переменную `attendance` как пустой словарь.
2.  Определи функцию `mark_attendance(section, count=1)`:
    *   Объяви, что переменная `attendance` внутри функции является глобальной.
    *   Если ключ `section` отсутствует в словаре `attendance`, добавь его со значением 0.
    *   Увеличь значение в словаре `attendance` по ключу `section` на величину `count`.
3.  Определи функцию `create_section_tracker(section_name)`:
    *   Внутри нее определи другую функцию (например, `inner_tracker`) без параметров:
        *   Объяви, что переменная `attendance` внутри этой внутренней функции является глобальной.
        *   Вызови `mark_attendance(section_name)` (или повтори логику добавления/увеличения).
        *   Верни текущее значение `attendance[section_name]`.
    *   Верни `inner_tracker` из внешней функции.

### Рекомендации
-   **Вынести в отдельную функцию:** Логику проверки наличия секции в словаре и инициализации нулем можно оставить внутри `mark_attendance`. Это естественное место для нее. Внутренняя функция замыкания будет делегировать работу `mark_attendance`.
-   **PEP8:**
    -   Используй `snake_case` для имен переменных и функций (`mark_attendance`, `section_name`).
    -   После определения функции оставляй две пустые строки перед следующим объявлением на верхнем уровне (например, между `def mark_attendance(...):` и `def create_section_tracker(...):`).
