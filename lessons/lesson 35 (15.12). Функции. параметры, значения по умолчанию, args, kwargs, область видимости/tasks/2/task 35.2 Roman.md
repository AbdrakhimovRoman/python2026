# Практическое задание 35.2

## Задания

### Описание задачи
Роман, ты уже освоил базовое объявление функций, передачу аргументов и использование `return`. В предыдущем блоке ты научился отличать параметры от аргументов и понимать, как функция получает входные данные и возвращает результат.

Сейчас мы переходим к важному практическому навыку: управлению аргументами функции. Этот блок посвящен использованию **значений по умолчанию** для параметров и правилам **порядка передачи** позиционных и именованных аргументов. Ты столкнешься с типичной "ловушкой" при использовании изменяемых объектов (например, списков) в качестве значений по умолчанию и научишься ее обходить с помощью **None-паттерна**. Это ключевой навык для написания надежных и предсказуемых функций, который подводит к более сложным темам работы с переменным числом аргументов.

**Контекст:** Ты разрабатываешь модуль для управления простой системой учета задач в проекте. Каждая задача имеет название, статус и может принадлежать к одной или нескольким категориям. Твоя задача — написать функцию, которая безопасно добавляет новую задачу в общий список, учитывая возможные настройки.

### Пример входных и выходных данных

**Пример 1: Базовый вызов с позиционными аргументами**
```python
backlog = []  # Исходный список задач пуст

# Вызов функции add_task с позиционными аргументами
add_task(backlog, "Написать ТЗ", "в работе")
print(backlog)
```
**Ожидаемый вывод:**
```
[{'title': 'Написать ТЗ', 'status': 'в работе', 'categories': []}]
```
*Пояснение:* Функция получила список `backlog`, название задачи и статус. Так как категории не указаны, использовано значение по умолчанию (пустой список). Задача добавлена в переданный список `backlog`.

**Пример 2: Вызов с именованными аргументами и изменением порядка**
```python
backlog = []
# Используем именованные аргументы, меняя их порядок
add_task(status="новая", title="Протестировать API", task_list=backlog)
print(backlog)
```
**Ожидаемый вывод:**
```
[{'title': 'Протестировать API', 'status': 'новая', 'categories': []}]
```
*Пояснение:* Аргументы переданы по имени, поэтому их порядок не важен. Параметр `task_list` получил значение `backlog`. Категории снова не указаны.

**Пример 3: Вызов с указанием категорий и демонстрация "ловушки"**
```python
backlog = []
# Первый вызов: добавляем задачу с категориями
add_task(backlog, "Исправить баг", "в работе", ["bugfix", "critical"])
print("После первого вызова:", backlog)

# Второй вызов: НЕ передаем категории. Что будет?
add_task(backlog, "Обновить документацию", "ожидает")
print("После второго вызова:", backlog)
```
**Ожидаемый корректный вывод (если функция написана правильно с None-паттерном):**
```
После первого вызова: [{'title': 'Исправить баг', 'status': 'в работе', 'categories': ['bugfix', 'critical']}]
После второго вызова: [{'title': 'Исправить баг', 'status': 'в работе', 'categories': ['bugfix', 'critical']}, {'title': 'Обновить документацию', 'status': 'ожидает', 'categories': []}]
```
*Пояснение:* Вторая задача должна получить свой собственный пустой список категорий, а не "унаследовать" список от первой задачи. Если функция написана некорректно (без None-паттерна), категории второй задачи окажутся привязаны к тому же списку, что и у первой, что является ошибкой.

### Критерии проверки и ограничения
1.  **Обязательные параметры функции:** `task_list` (список, в который добавляется задача), `title` (строка, название задачи), `status` (строка, статус задачи).
2.  **Параметр со значением по умолчанию:** `categories`. Его значение по умолчанию должно быть установлено безопасным способом, предотвращающим ошибку с общим изменяемым объектом между вызовами.
3.  **Порядок аргументов:** Функция должна корректно обрабатывать как позиционные, так и именованные аргументы. В вызове позиционные аргументы должны идти перед именованными.
4.  **Возвращаемое значение:** Функция не должна возвращать значение (т.е., по сути, возвращает `None`). Ее задача — изменить переданный список `task_list`.
5.  **Структура задачи:** Каждая задача должна быть представлена словарем с ключами: `'title'`, `'status'`, `'categories'`.
6.  **Запрещено использовать:** `*args`, `**kwargs`, распаковку, глобальные переменные (кроме тех, что переданы в функцию), любые темы из будущих блоков.

### Решение задачи (псевдокод)
1.  Объяви функцию `add_task` с параметрами: `task_list`, `title`, `status`, `categories`.
2.  Для параметра `categories` задай значение по умолчанию таким образом, чтобы избежать проблемы общего изменяемого списка между вызовами. (Подсказка: используй специальное значение, указывающее на "отсутствие значения", и создавай новый список внутри функции при необходимости).
3.  Внутри функции:
    a.  Если значение параметра `categories` указывает на "отсутствие значения", создай новый пустой список и присвой его переменной для категорий.
    b.  Создай словарь `new_task` с ключами `'title'`, `'status'`, `'categories'`. В качестве значения для `'categories'` используй список, полученный на предыдущем шаге.
    c.  Добавь словарь `new_task` в конец списка `task_list` (измени переданный список).
4.  Функция завершает работу без оператора `return` (или с `return None`).

### Рекомендации
-   **Вынести в отдельную функцию:** Данную задачу логично решить одной функцией `add_task`. Выносить что-либо еще не требуется.
-   **PEP8:**
    -   Используй `snake_case` для имен функций и переменных (`add_task`, `task_list`).
    -   После запятой, разделяющей параметры, ставь пробел: `def add_task(task_list, title, status, categories=None):`.
