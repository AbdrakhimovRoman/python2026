# Домашняя работа: Функции. Параметры, значения по умолчанию, args, kwargs, область видимости

## Задачи
1.  **Функция-калькулятор с гибкими аргументами**
    -   **Описание задачи:** Создай универсальную функцию для вычисления суммы, которая может принимать разное количество чисел. Задача тренирует использование `*args` для сбора позиционных аргументов, а также правильное применение `return` для получения результата, а не его печати. Это основа для понимания функций с переменным числом входных данных.
    -   **Пример (вход → выход):**
        -   `sum_all(10, 20, 30)` → `60`
        -   `sum_all(5)` → `5`
        -   `sum_all()` → `0` (граничный случай: функция должна корректно обрабатывать вызов без аргументов)
    -   **Критерии проверки и ограничения:**
        -   Функция должна быть объявлена с использованием `*args`.
        -   Результат должен возвращаться оператором `return`, а не выводиться `print` внутри функции.
        -   Функция должна корректно работать с любым количеством переданных чисел (включая ноль).
        -   Нельзя использовать глобальные переменные для хранения промежуточных результатов.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `sum_all`, которая принимает `*args`.
        2.  Инициализируй переменную для накопления суммы (например, `total`) значением 0.
        3.  Для каждого элемента в `args` добавь его значение к `total`.
        4.  Верни значение `total`.
    -   **Рекомендации:**
        -   **PEP8:** Название функции должно быть в `snake_case` и отражать ее действие (например, `sum_all` или `calculate_sum`). Используй отступ в 4 пробела для тела функции.

2.  **Создание профиля пользователя с параметрами по умолчанию**
    -   **Описание задачи:** Напиши функцию, которая формирует словарь с информацией о пользователе. Функция должна иметь параметры со значениями по умолчанию и безопасно обрабатывать изменяемый тип данных (список). Это упражнение закрепляет понимание значений по умолчанию и учит избегать классической ошибки с общим списком между вызовами.
    -   **Пример (вход → выход):**
        -   `create_profile("Анна", age=25)` → `{"name": "Анна", "age": 25, "hobbies": []}`
        -   `create_profile("Борис", hobbies=["чтение", "бег"])` → `{"name": "Борис", "age": 0, "hobbies": ["чтение", "бег"]}`
        -   `create_profile("Виктор")` → `{"name": "Виктор", "age": 0, "hobbies": []}`
    -   **Критерии проверки и ограничения:**
        -   Функция должна иметь параметры: `name` (обязательный), `age` (по умолчанию `0`), `hobbies` (по умолчанию безопасный пустой список).
        -   Нельзя допускать, чтобы два вызова функции с незаданным `hobbies` использовали один и тот же список в памяти.
        -   Возвращаемое значение — словарь с ключами `"name"`, `"age"`, `"hobbies"`.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `create_profile` с параметрами `name`, `age=0`, `hobbies=None`.
        2.  Внутри функции проверь, равен ли `hobbies` значению `None`.
        3.  Если да, создай новый пустой список и присвой его переменной `hobbies` (локально внутри функции).
        4.  Верни словарь `{"name": name, "age": age, "hobbies": hobbies}`.
    -   **Рекомендации:**
        -   **PEP8:** Для проверки на `None` используй оператор `is` (например, `if hobbies is None:`).

3.  **Форматирование данных с использованием распаковки**
    -   **Описание задачи:** Создай функцию, которая принимает информацию о товаре в виде отдельных аргументов, и другую функцию, которая умеет вызывать первую, распаковывая данные из словаря. Задача развивает навыки работы с `**kwargs` и распаковкой словаря при вызове функции, что часто используется при передаче конфигураций или данных.
    -   **Пример (вход → выход):**
        -   `format_item("Книга", 500, category="литература")` → `"Товар: Книга, Цена: 500, Категория: литература"`
        -   `item_data = {"name": "Мышь", "price": 1500, "category": "электроника"}`
          `call_with_unpacking(item_data)` → `"Товар: Мышь, Цена: 1500, Категория: электроника"`
    -   **Критерии проверки и ограничения:**
        -   Функция `format_item` должна принимать обязательные аргументы `name`, `price` и произвольное количество именованных аргументов через `**kwargs`. Она возвращает отформатированную строку.
        -   Функция `call_with_unpacking` принимает один словарь `data` и вызывает `format_item`, распаковывая этот словарь.
        -   В строке результата должны быть как минимум название и цена. Остальные переданные через `kwargs` параметры можно добавить в конец строки (например, перечислив их).
    -   **Решение (псевдокод):**
        1.  Для `format_item(name, price, **kwargs)`:
            *   Создай базовую строку: `"Товар: {name}, Цена: {price}"`.
            *   Пройдись по элементам словаря `kwargs` и добавь их к строке в формате `", {ключ}: {значение}"`.
            *   Верни полученную строку.
        2.  Для `call_with_unpacking(data)`:
            *   Вызови функцию `format_item(**data)` и верни ее результат.
    -   **Рекомендации:**
        -   **PEP8:** Если строка форматирования становится длинной, можно разбить ее на несколько строк, используя скобки и конкатенацию.

4.  **Управление счетчиком с четкой областью видимости**
    -   **Описание задачи:** Реализуй две стратегии работы со счетчиком: одна с использованием `global`, другая — без него, через возврат значения. Это упражнение наглядно демонстрирует разницу между изменением глобального состояния и чистым подходом, развивая понимание области видимости переменных.
    -   **Пример (вход → выход):**
        -   **Способ 1 (с `global`):**
            ```
            counter = 0
            increment_global()
            print(counter) # -> 1
            increment_global()
            print(counter) # -> 2
            ```
        -   **Способ 2 (без `global`):**
            ```
            counter = 0
            counter = increment_pure(counter)
            print(counter) # -> 1
            counter = increment_pure(counter)
            print(counter) # -> 2
            ```
    -   **Критерии проверки и ограничения:**
        -   Реализуй функцию `increment_global()`, которая увеличивает глобальную переменную `counter` на 1. Не принимает аргументов, не возвращает значения (`None`).
        -   Реализуй функцию `increment_pure(current_value)`, которая принимает текущее значение счетчика, возвращает увеличенное на 1 значение, но не изменяет переданный аргумент и не использует глобальные переменные.
        -   Покажи вызов обеих функций и вывод результата.
    -   **Решение (псевдокод):**
        1.  Объяви глобальную переменную `counter = 0`.
        2.  Для `increment_global()`:
            *   Объяви, что внутри функции `counter` — это глобальная переменная (`global counter`).
            *   Увеличь `counter` на 1.
        3.  Для `increment_pure(current_value)`:
            *   Верни результат выражения `current_value + 1`.
        4.  В основной программе продемонстрируй работу обеих функций, выводя значение `counter` после каждого вызова.
    -   **Рекомендации:**
        -   **Вынос функциональности:** В этом задании две функции уже являются отдельными логическими единицами. Не нужно создавать дополнительные.
        -   **PEP8:** Использование `global` часто считается нежелательным в больших проектах, так как усложняет понимание потока данных. Функция `increment_pure` является более предсказуемой и тестируемой.
