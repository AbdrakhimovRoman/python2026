# Задание 33.4. Генераторы коллекций. list, dict, set comprehensions

## Блок урока
«Set comprehensions» позволяют собирать уникальные значения после сложной фильтрации и пересечений наборов.

## Условие задачи
**Сложность**: <span style="color: #c62828">● сложный</span>. примерное время: 15–20 минут

Есть список `deploys`, где каждая запись — словарь:
- `"name"`: название релиза
- `"regions"`: список доступных регионов
- `"checks"`: список словарей `{ "region": str, "passed": bool }`

Нужно построить множество `unsafe_regions`, в которое попадут регионы, присутствующие в `regions`, но имеющие хотя бы одну проверку с `passed == False`. Используй одно выражение set comprehension с вложенными циклами.

## Пример входных данных
```
deploys = [
    {
        "name": "v1",
        "regions": ["eu", "us"],
        "checks": [
            {"region": "eu", "passed": True},
            {"region": "us", "passed": False}
        ]
    },
    {
        "name": "v2",
        "regions": ["apac"],
        "checks": [
            {"region": "apac", "passed": True},
            {"region": "eu", "passed": False}
        ]
    }
]
```

## Пример выходных данных
```
{'us'}
```

## Критерии успешного выполнения
- Множество `unsafe_regions` формируется единственным set comprehension.
- В результат попадают только регионы, перечисленные в `regions` конкретного релиза.
- Для включения достаточно одной проваленной проверки.
- Исходная структура `deploys` не изменяется.

## Подсказки
- Используй вложенный проход `for deploy in deploys for check in deploy["checks"]`.
- Проверяй `check["region"] in deploy["regions"]` перед добавлением.
- Логическое условие `if not check["passed"]` оставь в конце comprehension.

## Частые ошибки и ограничения
- Не добавляй `set()` вокруг comprehension и не используй `add`.
- Следи, чтобы не повторялись элементы списков более чем на пять пунктов.
- Не забывай про точное сравнение булевых значений.
