Вопросы с выбором варианта: 70/100%  
Вопросы с текстовыми ответами: 0/0%  
# Вопрос 1. Тема 1: Условные конструкции и циклы в Python
  
Какие значения в Python считаются ложными (falsy)?
  
Варианты ответов:
1) ✅ Значения, приводимые к False
2) Только None
3) Только отрицательные числа
4) Только значение 0
5) Только пустые строки
  
### ИИ анализ  
Правильный ответ выбран верно. В Python к ложным (falsy) относятся значения, которые при приведении к булевому типу дают `False`.  Это включает `None`, `False`, нули числовых типов, пустые коллекции (список, кортеж, словарь, множество) и пустые строки.  Важно понимать, что это не одно конкретное значение, а целая категория.

# Вопрос 2. Тема 1: Условные конструкции и циклы в Python
  
Зачем используется `elif`?
  
Варианты ответов:
1) Для остановки цикла
2) Для вывода текста
3) Для обработки исключений
4) Для создания функции
5) ✅ Для добавления нового условия
  
### ИИ анализ  
Ответ правильный. Ключевое слово `elif` (сокращение от "else if") используется для проверки дополнительных условий после начального `if`, когда предыдущие условия не выполнились.  Это позволяет создавать цепочки ветвлений, делая код чище и эффективнее, чем вложенные `if-else` блоки.

# Вопрос 3. Тема 1: Условные конструкции и циклы в Python
  
В каком случае удобнее использовать `for`?
  
Варианты ответов:
1) Когда нужно ждать событие
2) Когда нет итератора
3) Когда нужно повторять бесконечно
4) Когда условие меняется случайно
5) ✅ Когда известен набор значений
  
### ИИ анализ  
Ответ верный. Цикл `for` идеально подходит для итерации по заранее известной или определяемой последовательности (например, списку, строке, диапазону `range`).  Он автоматически перебирает элементы, избавляя программиста от необходимости вручную управлять индексом или условием остановки, в отличие от цикла `while`.

# Вопрос 4. Тема 1: Условные конструкции и циклы в Python
  
В каком случае удобнее использовать `while`?
  
Варианты ответов:
1) Когда есть список значений
2) ✅ Когда условие важно каждый раз
3) Когда нужна сортировка
4) Когда нужен словарь
5) Когда есть range
  
### ИИ анализ  
Ответ правильный. Цикл `while` используется, когда количество итераций заранее неизвестно и выполнение зависит от условия, которое проверяется перед каждой итерацией.  Он продолжает работу, пока условие истинно, что полезно для обработки событий, чтения потоков данных или ожидания изменения состояния.

# Вопрос 5. Тема 1: Условные конструкции и циклы в Python
  
Что делает `break`?
  
Варианты ответов:
1) Переходит в else блока
2) Останавливает программу
3) Пропускает итерацию
4) Перезапускает цикл
5) ✅ Полностью прерывает цикл
  
### ИИ анализ  
Ответ верный. Оператор `break` используется для немедленного и полного выхода из цикла (`for` или `while`), прерывая все последующие итерации.  Управление передаётся следующей за циклом инструкции. Это полезно для досрочного завершения цикла при нахождении искомого элемента или возникновении ошибки.

# Вопрос 6. Тема 1: Условные конструкции и циклы в Python
  
Что делает `continue`?
  
Варианты ответов:
1) Переходит к else блока
2) Завершает программу
3) Завершает цикл полностью
4) ✅ Пропускает текущую итерацию
5) Возвращает значение
  
### ИИ анализ  
Ответ правильный. Оператор `continue` прерывает выполнение только текущей итерации цикла и немедленно переходит к проверке условия (в `while`) или к следующему элементу (в `for`).  Он полезен для пропуска определённых элементов, которые не требуют обработки, без выхода из всего цикла.

# Вопрос 7. Тема 1: Условные конструкции и циклы в Python
  
Когда выполняется `else` в конструкции `for ... else`?
  
Варианты ответов:
1) Только если цикл пустой
2) Только при ошибке
3) Только если был `continue`
4) Всегда после первого шага
5) ✅ Если цикл завершился без `break`
  
### ИИ анализ  
Ответ верный. Блок `else`, связанный с циклом `for`, выполняется только в том случае, если цикл завершился естественным образом, то есть не был прерван оператором `break`.  Это удобный паттерн для поиска, когда нужно выполнить действие, если искомый элемент не был найден в последовательности.

# Вопрос 8. Тема 1: Условные конструкции и циклы в Python
  
Как записать тернарное выражение (условие в одну строку) в Python?
  
Варианты ответов:
1) `if (a) {b} else {c}`
2) `b unless a else c`
3) `if a: b else: c`
4) ❌ `a ? b : c`
5) `b if a else c`
  
### ИИ анализ  
Выбран неверный вариант. Синтаксис `a ? b : c` характерен для языков C, Java, JavaScript, но не для Python.  Правильный синтаксис тернарного условного оператора в Python — `<значение_if_true> if <условие> else <значение_if_false>`.  В данном случае верным был бы вариант 5.

# Вопрос 9. Тема 1: Условные конструкции и циклы в Python
  
Что такое итерация в цикле `for`?
  
Варианты ответов:
1) Создание списка
2) Объявление переменной
3) Запуск программы
4) ✅ Один проход тела цикла
5) Завершение цикла
  
### ИИ анализ  
Ответ правильный. Итерация — это однократное выполнение тела цикла для текущего элемента итерируемого объекта.  В цикле `for` каждая итерация присваивает переменной цикла следующее значение из последовательности и выполняет блок кода внутри цикла.

# Вопрос 10. Тема 1: Условные конструкции и циклы в Python
  
Как остановить цикл `while True` изнутри цикла?
  
Варианты ответов:
1) Использовать `pass`
2) Использовать `print`
3) Использовать `continue`
4) ✅ Использовать `break`
5) Использовать `elif`
  
### ИИ анализ  
Ответ верный. Цикл `while True` является бесконечным, так как его условие всегда истинно.  Единственный способ корректно завершить его — использовать оператор `break` внутри тела цикла при выполнении определённого условия.  Оператор `continue` в данном случае лишь перейдёт к следующей итерации.

# Вопрос 11. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Чем отличается `list.append(x)` от `list.extend(iterable)`?
  
Варианты ответов:
1) `extend` удаляет элементы
2) ✅ `append` добавляет один элемент
3) `extend` добавляет один элемент
4) Разницы нет
5) `append` добавляет все элементы
  
### ИИ анализ  
Ответ правильный. Метод `append(x)` добавляет объект `x` как один новый элемент в конец списка, даже если `x` является списком (тогда получится вложенный список).  Метод `extend(iterable)` добавляет все элементы из итерируемого объекта `iterable` по отдельности, расширяя исходный список.

# Вопрос 12. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Как обратиться к последнему элементу списка по индексу?
  
Варианты ответов:
1) `a[0]`
2) `a[1]`
3) `a[last]`
4) ✅ `a[-1]`
5) `a[end]`
  
### ИИ анализ  
Ответ верный. В Python поддерживается отрицательная индексация. Индекс `-1` ссылается на последний элемент списка, `-2` — на предпоследний и так далее.  Это удобный и идиоматичный способ доступа к элементам с конца без необходимости знать точную длину списка.

# Вопрос 13. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Что означает `start` в срезе `[start:stop:step]`?
  
Варианты ответов:
1) Тип результата
2) Количество элементов
3) Шаг среза
4) ✅ Индекс начала среза
5) Индекс конца среза
  
### ИИ анализ  
Ответ правильный. Параметр `start` в срезе задаёт индекс первого элемента, который будет включён в результирующий срез.  Если `start` не указан, срез начинается с первого элемента последовательности. Индексация начинается с 0.

# Вопрос 14. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Что означает `stop` в срезе `[start:stop:step]`?
  
Варианты ответов:
1) ✅ Индекс конца, не включая
2) Индекс начала
3) Значение элемента
4) Размер списка
5) Шаг
  
### ИИ анализ  
Ответ верный. Параметр `stop` определяет индекс, *до которого* (но не включая его) берутся элементы.  Это важный нюанс: элемент с индексом `stop` в срез не попадает. Если `stop` не указан, срез идёт до конца последовательности.

# Вопрос 15. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Что означает `step` в срезе `[start:stop:step]`?
  
Варианты ответов:
1) Индекс конца
2) ✅ Шаг выборки элементов
3) Индекс начала
4) Тип списка
5) Длину списка
  
### ИИ анализ  
Ответ правильный. Параметр `step` определяет шаг, с которым выбираются элементы из диапазона `[start:stop]`.  Например, `step=2` возьмёт каждый второй элемент. Отрицательный шаг позволяет создавать срезы в обратном порядке.

# Вопрос 16. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Чем отличается `list.copy()` от `list2 = list1`?
  
Варианты ответов:
1) `copy()` делает новый список
2) ❌ `=` делает глубокую копию
3) `=` копирует элементы
4) Разницы нет
5) `copy()` связывает ссылки
  
### ИИ анализ  
Выбран неверный вариант. Оператор присваивания `list2 = list1` создаёт новую ссылку на тот же объект в памяти (поверхностное связывание), а не глубокую копию.  Метод `list.copy()` создаёт новый список (поверхностную копию), содержащий ссылки на те же вложенные объекты, что и оригинал.

# Вопрос 17. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Как правильно создать список списков без «общей» вложенной ссылки?
  
Варианты ответов:
1) `a = (0, 0, 0)`
2) `a = {0: 3}`
3) ✅ `a = [[0] * 3 for _ in range(3)]`
4) `a = [[0] * 3] * 3`
5) `a = [0] * 9`
  
### ИИ анализ  
Ответ верный. Конструкция `[[0] * 3 for _ in range(3)]` использует list comprehension, который на каждой итерации создаёт новый внутренний список `[0, 0, 0]`.  Вариант `[[0] * 3] * 3` создаёт один внутренний список и затем три ссылки на него, что приводит к изменению всех строк при изменении одной.

# Вопрос 18. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Что такое list comprehension?
  
Варианты ответов:
1) Способ сортировки
2) Вид цикла while
3) Способ чтения файла
4) Тип словаря
5) ✅ Короткая запись создания списка
  
### ИИ анализ  
Ответ правильный. List comprehension (генератор списка) — это компактный синтаксис для создания нового списка путём применения выражения к каждому элементу итерируемого объекта, с возможной фильтрацией.  Он часто заменяет цикл `for` с `append` и делает код более читаемым и эффективным.

# Вопрос 19. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Чем отличается удаление по индексу и удаление по значению в списке?
  
Варианты ответов:
1) По значению удаляют диапазон
2) По значению удаляют индекс
3) ❌ Разницы нет
4) По индексу удаляют позицию
5) По индексу удаляют все совпадения
  
### ИИ анализ  
Выбран неверный вариант. Разница есть. Метод `list.pop(index)` удаляет элемент по заданному индексу и возвращает его.  Метод `list.remove(value)` удаляет *первое* вхождение элемента с указанным значением. Если значение не найдено, `remove()` вызывает ошибку `ValueError`.

# Вопрос 20. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Чем отличается `sort()` от `sorted()`?
  
Варианты ответов:
1) `sort()` возвращает новый список
2) ✅ `sort()` меняет список на месте
3) `sorted()` работает только с set
4) `sorted()` меняет список
5) Разницы нет
  
### ИИ анализ  
Ответ верный. Метод `list.sort()` сортирует исходный список *на месте* (in-place) и возвращает `None`.  Встроенная функция `sorted(iterable)` возвращает *новый* отсортированный список, не изменяя исходную коллекцию. `sorted()` работает с любым итерируемым объектом.

# Вопрос 21. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Чем отличается `d.get(key)` от `d[key]`, если ключа нет?
  
Варианты ответов:
1) `[]` вернёт None по умолчанию
2) Разницы нет
3) `get` удалит ключ
4) `get` всегда вызывает ошибку
5) ✅ `get` вернёт None по умолчанию
  
### ИИ анализ  
Ответ правильный. Обращение `d[key]` к отсутствующему ключу вызывает исключение `KeyError`.  Метод `d.get(key)` в такой ситуации по умолчанию возвращает `None` (или другое значение, указанное вторым аргументом), что делает код безопаснее при работе с потенциально отсутствующими ключами.

# Вопрос 22. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Как добавить или обновить значение в словаре по ключу?
  
Варианты ответов:
1) `d.insert(key)`
2) `d.append(value)`
3) `d.add(k, v)`
4) ✅ `d[key] = value`
5) `d.push(k, v)`
  
### ИИ анализ  
Ответ верный. Операция присваивания `d[key] = value` является основным способом добавления новой пары ключ-значение в словарь.  Если ключ уже существует, его значение будет обновлено. Методы `insert`, `append`, `add` и `push` для стандартных словарей не существуют.

# Вопрос 23. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Что возвращает `dict.keys()`?
  
Варианты ответов:
1) ✅ Представление ключей (view)
2) Список ключей
3) Пару ключ-значение
4) Количество ключей
5) Только первый ключ
  
### ИИ анализ  
Ответ правильный. В Python 3 методы `dict.keys()`, `.values()` и `.items()` возвращают объекты представления (view objects).  Эти представления динамически отражают изменения в словаре и поддерживают операции над множествами (для `.keys()` и `.items()`), но не являются списка